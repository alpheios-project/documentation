# Git workflows

# Standard workflow

This is a workflow that will be used for development of a new feature in majority of cases. Please see details on a diagram below.

![Standard workflow diagram](https://raw.githubusercontent.com/alpheios-project/documentation/master/development/git-workflow/git-std-worklow-proposal.svg?sanitize=true)

When a new feature development is started, a separate feature branch is created for it. This branch will contain code of this feature only. Once development of this feature and its dev testing are complete, a feature branch is merged into master. A feature branch can be deleted after the merge.

A feature is moved to QA from a `master` branch. If `master` contains other new features at the moment, all those feature will go to QA and will be tested simultaneously. If any issues are found during QA testing, they are fixed within the QA branch.

Changes that are approved by QA are merged into a `production` branch. We also need to merge a `production` branch to `master` to bring `master` up to date with the latest fixes.

Each merge into `production` increases a version number in `package.json`. The version is increased according to what features are added. If two or more features of different significance (major/minor/patch) are added, only the single most significant feature is used to increase a version number. Here are some of examples to illustrate this. It shows an initial version, a features that were added, and a resulting version:
* 1.2.3 + patch -> 1.2.4
* 1.2.3 + minor -> 1.3.0
* 1.2.3 + major -> 2.0.0
* 1.2.3 + minor + patch -> 1.3.0 (minor feature masks patch)
* 1.2.3 + major + minor -> 2.0.0 (major feature masks minor)
* 1.2.3 + minor + minor -> 1.3.0 (two minor features are counted as one)

This is an algorithm that is implemented in tools that support conventional commits, including Lerna's version, and it would makes sense for us to follow it too.

If no merges to `production` are made, the version is not increases, no matter what changes were made. We can use conventional commits selectively (i.e. not every commit is a conventional one but only those which commit messages convey information about what feature was added) to store data about features added. This info is stored in git history and then we can use tools like Lerna version to set a version number using that information. We also could not use conventional commits at all and set version manually when code is merged from `qa` to `production`.

As dev (`master`), feature, and qa branches are "versionless" (has no useful version information) we will use autogenerated build numbers and tags to designate code from specific commits. A build number format is `branch-name.12345678`. It consist from a branch name (for `master` branch we will use `dev` instead of a branch name) and a nine digit number that reflects a point in time. The higher the number is, the later commit was made. Please see about how that number is generated [here](https://github.com/prantlf/build-number-generator). Branch name prefix is used to distinguish between two different commits from different branches that are made at the same time. Without this prefix they will have the same number. Branch name also helps to understand what's the purpose of the code built: is it QA, feature branch, or the main dev branch (i.e. `master`).

`production` branch contains code that is ready for production use. We, however, may not be willing to make each merge in there available to our users automatically. In that case we'll publish such commits to npm with the `rc` tag which won't be used by default. But if we're ready to share updates, they will be published with the `latest` tag, a default one.

# Fast track workflow

This workflow is used on special occasions when do have some features in QA testing already but we want one or several other features to be released before them. For that we will use a special `ftqa` branch that will isolate fast track feature from features that are already in a `qa` branch.

This workflow is more complex and should be used only when it is absolutely necessary.

![Fast track workflow diagram](https://raw.githubusercontent.com/alpheios-project/documentation/master/development/git-workflow/git-fast-track-worklow-proposal.svg?sanitize=true)

The fast track workflow differs from the regular one in the following:
* We do not merge changes from master to a fast track feature development branch and we do not merge a fast track branch to master before merging a fast track branch to QA. At that moment `master` may already contain other new features. We don't want them to be combined with the fast track features. We want to isolate the fast track features so that they will be tested and released on their own.
* We merge changes from the fast track feature development branch into a special fast track `ftqa` branch, not to the regular `qa` branch. This is to isolate fast track features from the rest.
* After a fast track QA testing is completed, a `ftqa` branch is merged to `production`. Then in needs to be merged back to the regular `qa` branch. That will add fast track changes to those that are currently in QA. After that a fast-track QA branch is not needed and can be deleted.

# Versioning of the code

A version is changed only when code is merged to a `production` branch. This will trigger a code deployment to npm with either the `latest` (in that case code will become available to all Alpheios clients by default) or `rc` tag (then the code will be used only by those who target it specifically). We will use pre-set scripts to control the deployment.

In all other branches we'll use a build number within a tagged commit to designate a specific release, such as different QA builds. To create it, we'll use an npm script that will:
1. Generate a build number. A build number format in `branch-name.YYYYMMDDCCCC`, where `CCC` is a number of two-minute interval within a day, e.g. `qa.20200228351`. If the branch is `master` we'll use `dev` instead of a branch name (`dev.20200228351`). If the branch is `producion`, we'll omit a branch name: `20200228351`.
2. Rebuild deliverables and inject a build number into them by webpack.
3. Create a commit with updated deliverables.
4. Tag that commit with a build number.

# Build Process for Creating a QA build

Prerequisite: create qa branches on alpheios-core, embed-lib and webextension and push them upstream. 

1. alpheios-core: merge master to qa
2. alpheios-core: run `npm install && npm update`
3. alpheios-core: run `npm tagged-commit`
4. alpheios-core run `git push && git push --tag`
5. embed-lib: merge master to qa
6. embed-lib: run `npm install && npm update`
7. embed-lib: run `npm tagged-commit`
8. embed-lib run `git push && git push --tag`
9. webextension: merge master to qa
10. webextension: run `npm install && npm update`
11. webextension: run `npm tagged-commit`
12. webextension: run `git push && git push --tag`

After these steps, we should have the following
1. new packages of alpheios-components and alpheios-embedded on NPM with the `@qa` tag
2. GitHub releases of alpheios-core, webextension and embed-lib in GitHub

Running `tagged-commit` in __alpheios-core__ automates these steps:
1. increases the build number and exports it to an environment variable which webpack injects into the code
2. updates package.json to include the build number
3. rebuilds
4. tags the build

Running `tagged-commit` in __embed-lib__ automates these steps:
1. pulls in the `qa` branch of alpheios-core
2. increases the build number and exports it to an environment variable which webpack injects into the code
3. updates package.json to include the build number
4. rebuilds
5. tags the build 

The webextension build:
1. pulls in the `qa` branch of alpheios-core
2. increases the build number and exports it to an environment variable which webpack injects into the code
3. rebuilds 
4. tags the build

Outstanding issues:

1. Ideally, everything except the merge of master to qa would be automated, so that a merge to qa from master would just kick off the build to run on the travis servers. 
2. We still need to figure out how we want to handle integrating the alpheios auxiliary libraries into this process (alpheios-messaging, etc.)
3. We should make sure that whenever a release goes to production, the base version of everything in master gets updated so that dev and qa builds always are higher versions than production.







