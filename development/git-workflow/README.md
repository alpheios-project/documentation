# Git workflows

# Standard workflow

This is a workflow that will be used for development of a new feature in majority of cases. Please see details on a diagram below.

![Standard workflow diagram](https://raw.githubusercontent.com/alpheios-project/documentation/dev-cd/development/git-workflow/git-std-worklow-proposal.svg?sanitize=true)

When a new feature development is started, a separate feature branch is created for it. This branch will contain code of this feature only. Once development of this feature and its dev testing are complete, a feature branch is merged into master. A feature branch can be deleted after the merge.

A feature is moved to QA from a `master` branch. If `master` contains other new features at the moment, all those feature will go to QA and will be tested simultaneously. If any issues are found during QA testing, they are fixed within the QA branch.

Changes that are approved by QA are merged into a `production` branch. We also need to merge a `production` branch to `master` to bring `master` up to date with the latest fixes.

Each merge into `production` increases a version number in `package.json`. The version is increased according to what features are added. If two or more features of different significance (major/minor/patch) are added, only the single most significant feature is used to increase a version number. Here are some of examples to illustrate this. It shows an initial version, a features that were added, and a resulting version:
* 1.2.3 + patch -> 1.2.4
* 1.2.3 + minor -> 1.3.0
* 1.2.3 + major -> 2.0.0
* 1.2.3 + minor + patch -> 1.3.0 (minor feature masks patch)
* 1.2.3 + major + minor -> 2.0.0 (major feature masks minor)
* 1.2.3 + minor + minor -> 1.3.0 (two minor features are counted as one)
This is an algorithm that is implemented in tools that support conventional commits, including Lerna's version, and it would makes sense for us to follow it too.

If no merges to `production` are made, the version is not increases, no matter what changes were made. We can use conventional commits selectively (i.e. not every commit is a conventional one but only those which commit messages convey information about what feature was added) to store data about features added. This info is stored in git history and then we can use tools like Lerna version to set a version number using that information. We also could not use conventional commits at all and set version manually when code is merged from `qa` to `production`.

As dev (`master`), feature, and qa branches are "versionless" (has no useful version information) we will use autogenerated build numbers and tags to designate code from specific commits. A build number format is `branch-name.12345678`. It consist from a branch name (for `master` branch we will use `dev` instead of a branch name) and a nine digit number that reflects a point in time. The higher the number is, the later commit was made. Please see about how that number is generated [here](https://github.com/prantlf/build-number-generator). Branch name prefix is used to distinguish between two different commits from different branches that are made at the same time. Without this prefix they will have the same number. Branch name also helps to understand what's the purpose of the code built: is it QA, feature branch, or the main dev branch (i.e. `master`).

`production` branch contains code that is ready for production use. We, however, may not be willing to make each merge in there available to our users automatically. In that case we'll publish such commits to npm with the `rc` tag which won't be used by default. But if we're ready to share updates, they will be published with the `latest` tag, a default one.

# Fast track workflow

This workflow is used on special occasions when do have some features in QA testing already but we want one or several other features to be released before them. For that we will use a special `ftqa` branch that will isolate fast track feature from features that are already in a `qa` branch.

This workflow is more complex and should be used only when it is absolutely necessary.

![Fast track workflow diagram](https://raw.githubusercontent.com/alpheios-project/documentation/dev-cd/development/git-workflow/git-fast-track-worklow-proposal.svg?sanitize=true)

The fast track workflow differs from the regular one in the following:
* We do not merge changes from master to a fast track feature development branch and we do not merge a fast track branch to master before merging a fast track branch to QA. At that moment `master` may alread contain other new features. We don't want them to be combined with the fast track features. We want to isolate the fast track features so that they will be tested and released on their own.
* We merge changes from the fast track feature development branch into a special fast track `ftqa` branch, not to the regular `qa` branch. This is to isolate fast track features from the rest.
* After a fast track QA testing is completed, a `ftqa` branch is merged to `production`. Then in needs to be merged back to the regular `qa` branch. That will add fast track changes to those that are currently in QA. After that a fast-track QA branch is not needed and can be deleted.

# Version changes

Certain waypoints of the workflow result in a version update. This may or may not trigger a new code deployment. We will use pre-set scripts to control what and how needs to be deployed. We will use functionalities of Lerna and Travis to implement a version change and a deployment of build artifacts. 

