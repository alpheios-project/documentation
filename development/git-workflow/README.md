# Git workflows

# Standard workflow

This is a workflow that will be used for development of a new feature in majority of cases. Please see details on a diagram below.

![Standard workflow diagram](https://raw.githubusercontent.com/alpheios-project/documentation/master/development/git-workflow/git-std-worklow-proposal.svg?sanitize=true)

When a new feature development is started, a separate feature branch is created for it. This branch will contain code of this feature only. Once development of this feature and its dev testing are complete, a feature branch is merged into master. A feature branch can be deleted after the merge.

A feature is moved to QA from a `master` branch. If `master` contains other new features at the moment, all those feature will go to QA and will be tested simultaneously. If any issues are found during QA testing, they are fixed within the QA branch.

Changes that are approved by QA are merged into a `production` branch. We also need to merge a `production` branch to `master` to bring `master` up to date with the latest fixes.

Each merge into `production` increases a version number in `package.json`. The version is increased according to what features are added. If two or more features of different significance (major/minor/patch) are added, only the single most significant feature is used to increase a version number. Here are some of examples to illustrate this. It shows an initial version, a features that were added, and a resulting version:
* 1.2.3 + patch -> 1.2.4
* 1.2.3 + minor -> 1.3.0
* 1.2.3 + major -> 2.0.0
* 1.2.3 + minor + patch -> 1.3.0 (minor feature masks patch)
* 1.2.3 + major + minor -> 2.0.0 (major feature masks minor)
* 1.2.3 + minor + minor -> 1.3.0 (two minor features are counted as one)

This is an algorithm that is implemented in tools that support conventional commits, including Lerna's version, and it would makes sense for us to follow it too.

If no merges to `production` are made, the version is not increases, no matter what changes were made. We can use conventional commits selectively (i.e. not every commit is a conventional one but only those which commit messages convey information about what feature was added) to store data about features added. This info is stored in git history and then we can use tools like Lerna version to set a version number using that information. We also could not use conventional commits at all and set version manually when code is merged from `qa` to `production`.

As dev (`master`), feature, and qa branches are "versionless" (has no useful version information) we will use autogenerated build numbers and tags to designate code from specific commits. A build number format is `branch-name.12345678`. It consist from a branch name (for `master` branch we will use `dev` instead of a branch name) and a nine digit number that reflects a point in time. The higher the number is, the later commit was made. Please see about how that number is generated [here](https://github.com/prantlf/build-number-generator). Branch name prefix is used to distinguish between two different commits from different branches that are made at the same time. Without this prefix they will have the same number. Branch name also helps to understand what's the purpose of the code built: is it QA, feature branch, or the main dev branch (i.e. `master`).

`production` branch contains code that is ready for production use. We, however, may not be willing to make each merge in there available to our users automatically. In that case we'll publish such commits to npm with the `rc` tag which won't be used by default. But if we're ready to share updates, they will be published with the `latest` tag, a default one.

# Fast track workflow

This workflow is used on special occasions when do have some features in QA testing already but we want one or several other features to be released before them. For that we will use a special `ftqa` branch that will isolate fast track feature from features that are already in a `qa` branch.

This workflow is more complex and should be used only when it is absolutely necessary.

![Fast track workflow diagram](https://raw.githubusercontent.com/alpheios-project/documentation/master/development/git-workflow/git-fast-track-worklow-proposal.svg?sanitize=true)

The fast track workflow differs from the regular one in the following:
* We do not merge changes from master to a fast track feature development branch and we do not merge a fast track branch to master before merging a fast track branch to QA. At that moment `master` may already contain other new features. We don't want them to be combined with the fast track features. We want to isolate the fast track features so that they will be tested and released on their own.
* We merge changes from the fast track feature development branch into a special fast track `ftqa` branch, not to the regular `qa` branch. This is to isolate fast track features from the rest.
* After a fast track QA testing is completed, a `ftqa` branch is merged to `production`. Then in needs to be merged back to the regular `qa` branch. That will add fast track changes to those that are currently in QA. After that a fast-track QA branch is not needed and can be deleted.

# Versioning of the code

A version is changed only when code is merged to a `production` branch. This will trigger a code deployment to npm with either the `latest` (in that case code will become available to all Alpheios clients by default) or `rc` tag (then the code will be used only by those who target it specifically). We will use pre-set scripts to control the deployment.

In all other branches we'll use a build number within a tagged commit to designate a specific release, such as different QA builds. To create it, we'll use an npm script that will:
1. Generate a build number. A build number format in `branch-name.YYYYMMDDCCCC`, where `CCC` is a number of two-minute interval within a day, e.g. `qa.20200228351`. If the branch is `master` we'll use `dev` instead of a branch name (`dev.20200228351`). If the branch is `producion`, we'll omit a branch name: `20200228351`.
2. Rebuild deliverables and inject a build number into them by webpack.
3. Create a commit with updated deliverables.
4. Tag that commit with a build number.

# Build Process for Creating a QA build

Prerequisite: create qa branches on alpheios-core, embed-lib and webextension and push them upstream. 

## Alpheios Core (alpheios-components package)

In alpheios-core repository merge master to qa.

The GitHubAction QA Build Workflow will run upon the merge. It executes the following steps:
   * Generates the build number and passes it to the node-build build script as a parameter. The build script injects it into the code.
   * Updates the lerna.json and package.json files of all packages to include the build number. The build number must be included in package.json so that we can publish multiples builds of the same base version on NPM.
   * Rebuilds the components package.
   * Tags the build and creates a release on GitHub.
   * Publishes the alpheios-components package to NPM

A successful outcome is a QA Release in GitHub and an alpheios-components package published to NPM under the `@qa` tag

## Webextension 

If there are alpheios-components changes, first complete the QA build of Alpheios Core.

If there are webextension code changes, merge the webextension repository master branch to qa.  This will kick off the QA Build workflow in GitHub actions.

If there are only alpheios-components changes and **no** changes in the webextension code, then the QA build can be started directly from GitHub Actions manually because there is nothing to merge from master to QA in the webextension repo. Go to the Actions tab of the alpheios-project/webextension repo in GitHub and start the QA Build workflow manually on the qa branch.

The GitHubAction QA Build Workflow of the webextension executes the following steps:
   * Installs the qa branch of alpheios-core
   * Generates the build number and passes it to the node-build build script as a parameter. The build script injects it into the code.
   * Rebuilds the code
   * Builds and zips the dist directory
   * Tags the build and creates a release on GitHub
    * Publishes the alpheios-embedded package to NPM

A successful outcome is a QA Release in GitHub with an installable dist.zip directory.

**NOTE**: The Safari build is still archived manually in XCode. This needs to be automated.

## Embedded Library

Merge the embed-lib repository master branch to qa.  This will kick off the QA Build workflow in GitHub actions.

The GitHubAction QA Build Workflow of the embed-lib executes the following steps:
   * Installs the qa branch of alpheios-core
   * Generates the build number and passes it to the node-build build script as a parameter. The build script injects it into the code.
   * Rebuilds the code
   * Tags the build and creates a release on GitHub and uploads the zipped dist directory as a release artifact.

A successful outcome is a QA Release in GitHub and an alpheios-embedded package published to NPM under the `@qa` tag

## Outstanding issues:

1. Add production workflow to GitHub Actions
1. Add the Safari build of the webextension to GitHub Actions
2. Clarify practice for updating and freezing dependencies, inclusing those of other alpheios auxiliary libraries  (alpheios-messaging, etc.)
3. Decide and document practice around updating base versions numbers in master (making sure dev and qa builds always are higher versions than production).






